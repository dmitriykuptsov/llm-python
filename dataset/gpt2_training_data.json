[
  {
    "source": "vpls",
    "page": 5,
    "text": "1.Introduction\nBack at the end of 1960’s when the Internet was a rather small network,\nwhich was interconnecting major universities, governmental and military\norganizations, very little attention was devoted to security. Nowadays,\nwhen the Internet has become extremely sophisticated in structure, con-\nnecting billions of devices ranging from small IoT-type devices to humon-\ngous data centers, security has gained number one priority. In present\ndays, a typical Intranet of an organization can include a number of ge-\nographically separated branch-ofﬁce networks (for example, consider a\nfactory that has many SCADA devices and a mission control center that\nis miles and miles away). Since these networks are geographically sepa-\nrated, connecting them becomes a necessity, and so is the security of these\nnetworks. This is when the layer-3 virtual private networks ( L3-VPN ) and\nlayer-2 virtual private LAN service ( L2-VPLS ) solutions become handy.\nScalability, and resilience to various attacks, from man-in-the-middle to\nintegrity violation attacks, to rather fundamental attacks on asymmet-\nric algorithms (such as RSA, DSA, and their elliptic curve counterparts,\nDifﬁe-Hellman and Elliptic Curve DH, for example) using, for example,\nShor’s quantum computer algorithm to factorize large numbers, and mas-\nsive brute force attacks on hash algorithms should be considered thor-\noughly. With this in mind, in this work, we present different security\nsolutions, which can be used to build secure L2 and L3 overlay networks.\nWe present the limitations of each solution and identify how they can be\navoided.\nWe start with background material on cryptography. Here we discuss\nvarious symmetric and asymmetric encryption algorithms, present the\ndeﬁnition of hash functions, which are considered secure nowadays, and\ndiscuss several key agreement algorithms. To make the discussion com-\nplete we present the threat that quantum computers pose for such algo-\n5"
  },
  {
    "source": "vpls",
    "page": 6,
    "text": "Introduction\nrithms as RSA and DH, and discuss how post-quantum algorithms such\nas those that are based on the lattice can be used as an alternative to\nclassical algorithms for encryption and signature constructions. Although\nnot considered as part of the present work, future work can include the\nperformance comparison of standardized RSA and DSA algorithms with\nthe performance of lattice-based algorithms incorporated into for exam-\nple Host Identity Protocol or even Transport Layer Security protocol. We\nthen move on to a discussion of TLS, SSL, IPsec, HIP, and SSH protocols\nand how those can be used to achieve integrity and conﬁdentiality of data\ntransmitted over insecure channels. Afterward, we discuss the results we\nhave obtained over several years. Here, we discuss our practical experi-\nence with scalable Host Identity Protocol-based L3-VPN and VPLS net-\nwork which was built using the same protocol. We devote a separate sec-\ntion on hardware-accelerated versions of AES and SHA-256 algorithms.\nWe conclude the results section with an analysis of the limitations of each\nsolution and present the results for the various micro-benchmarking set-\ntings.\n1.1 Questions\nIn this work, we ask several questions. These are not research questions,\nbut rather practical questions that we try to answer to ourselves in order\nto understand the usability of Python-based security solution. Since our\nwork focuses on the application of Host Identity Protocol (HIP) in VPN\nand VPLS settings we ask the following questions:\nFirst, what is the performance of the pure Python-based implementa-\ntion of symmetric key encryption and decryption routines as well as hash\nmethods and how do they compare to implementation, which uses spe-\ncial AES and SHA-256 CPU instructions. Here our focus is on the micro\nbenchmarking of two implementations of AES and SHA-256 hashing al-\ngorithms, identiﬁcation of the bottlenecks and further recommendations\nfor our prototype implementation of Host Identity Protocol based VPLS\nand L3-VPN.\nSecond, what is the scalability of Host Identity Protocol based VPLS and\nhow does it perform in emulated environments such as Mininet. Here we\nseek the answer to the question of whether the HIP-VPLS is usable in\nenvironments close to real-life setups.\nThird, what is the performance of Python-based HIP-VPLS on real hard-\n6"
  },
  {
    "source": "vpls",
    "page": 7,
    "text": "Introduction\nware . By asking such questions we want to ﬁnd the application niche of\nour security solution. In addition, we elaborate on the practical conﬁgu-\nration of HIP-VPLS using a central controller.\nThe ﬁnal question relates to to the deployment of scalable L3-VPN based\non Host Identity Protocol . Here we focus on rather a different approach to\nbuilding secure networks: we consider L3-VPN where nodes in different\nbranch ofﬁces form separate broadcast and multicast domains, but still\ncan communicate with each other (with the assistance of IPv4 or IPv6\nrouting protocols). Here, we want to answer how to tackle the scalability\nissues of VPN network by adding hierarchy into the architecture.\n7"
  },
  {
    "source": "vpls",
    "page": 8,
    "text": "Introduction\n8"
  },
  {
    "source": "vpls",
    "page": 9,
    "text": "2. Background\nSince we are going to discuss the security protocols in this work, we begin\nthis section with a shallow dive into cryptography basics. Here, we dis-\ncuss symmetric and asymmetric cryptography algorithms, to make the de-\nscription a little bit complete we show how the RSA algorithm works, dis-\ncuss Difﬁe-Hellman (DH) and its Elliptic Curve counterpart. We should\nmention that the current understanding inside the cryptographic commu-\nnity is such that Shor’s algorithm and its quantum computer implementa-\ntion theoretically can efﬁciently factorize big numbers and solve discrete\nlogarithm problems without trouble. This algorithm, if powerful enough\nquantum computers will exist shortly, puts the RSA and DH algorithms\n- the major building blocks of modern security solutions - at risk of be-\ning cracked (once the modulus of the RSA algorithm factorized into prime\ncomponents, the private key of the RSA the algorithm can be easily recov-\nered). We will conclude this part of the background material with the dis-\ncussion of post-quantum computer public key encryption solution based\non lattice (more speciﬁcally we will discuss Learning With Errors (LWE)\nthe problem, which is at the heart of modern public key cryptography).\nWe believe that, eventually, this type of cryptography will be the replace-\nment for traditional RSA and DH algorithms, which rely on the hardness\nof factorization of the big numbers and discrete logarithm problems. In\nthe epilogue of this section, we will put a few words on how lattice public\nkey cryptography can be used, for example, together with Host Identity\nProtocol.\nIn the second part of the background material, we will review the basics\nof the Host Identity Protocol, Transport Layer Security Protocol, and Se-\ncure Shell Protocol, since these protocols are essential for understanding\nthe secure tunneling protocols that we discuss in this work.\nWe will ﬁnalize the discussion of the background material with a short\n9"
  },
  {
    "source": "vpls",
    "page": 10,
    "text": "Background\noverview of various L2, L3 and L4 tunneling solutions, including L2 802.1Q\nQinQ tunneling, L3 Multi-Protocol Label Switching (MPLS), L4 tunneling\nusing TLS and SSH protocol.\n2.1 Cryptography basics\nCryptography comes in many ﬂavors: symmetric key cryptography (3DES,\nAES, Twoﬁsh, RC4) which, in turn, can be categorized into block cipher\nand stream cipher and asymmetric key cryptography (such as RSA, DSA,\nECDSA). There are also key exchange protocols such as Difﬁe-Hellamn\nand Elliptic Cryptography DH for negotiation of common keys over inse-\ncure channels. Different algorithms applicable in different settings de-\npending on requirements. Typically, as we will discuss later, symmet-\nric key cryptography is used to protect data-plane trafﬁc in networks,\nwhereas, asymmetric-key cryptography is more applicable to the common\nkey negotiation, authentication and identiﬁcation purposes [20].\n2.1.1 Symmetric cryptography\nWe start with the symmetric key cryptography. Common key and rather\ntrivial operations such as permutations and substitutions are at the heart\nof any symmetric key cryptography algorithm. Although this type of cryp-\ntography is efﬁcient because of the usage of efﬁcient operations, it comes\nwith a limitation though. In symmetric key cryptography, both sender and\nreceiver need to share the same key, which complicates such important\naspects as key distribution and revocation and so alone this encryption\nsolution a very hard to use in modern cryptosystems. Typically, asymmet-\nric key cryptography such as RSA or DH is used to derive session keys –\nTLS, HIP, and many other protocols follow this design idea.\nSymmetric key cryptography comes in two different ﬂavors: block and\nstream. For example, block cipher (such as AES, 3DES, Twoﬁsh [20]) use\nblocks of data (typically, the size of the key is 128,192,256bits [20], and\ntypical block size is 64, or128bits), and encrypts or decrypts one block at\na time. There are different modes of operation, though, for block ciphers,\nexamples are counter mode and cipher block chaining. The latter uses a\nso-called initialization vector to add extra randomness into the encryption\nprocess, and encryption of proceeding blocks depends on the output of the\nprevious block. Modes of operations are important for security reasons.\n10"
  },
  {
    "source": "vpls",
    "page": 11,
    "text": "Background\nHowever, not all modes of operation are useful and secure. For example,\nElectronic Code Book (ECB), while achieving fast processing and paral-\nlelization, is considered insecure in many settings.\nThe other type of symmetric key algorithm is stream cipher. Here the\nencryption and decryption are performed on separate bits, one bit at a\ntime. CR4 is an example of a stream cipher. Stream ciphers are extremely\nimportant in real-time processing, for example, Wi-Fi uses stream ciphers\nto encrypt the data plane trafﬁc.\n2.1.2 Asymmetric cryptography\nAsymmetric key cryptography, in its simplest form, is brilliant in the age\nof computing. Guessing from the name that this type of cryptography\nuses different keys for encryption and decryption does not require deep\nthought. This property makes this group of algorithms suitable for vari-\nous key distribution, revocation, and signature ideas.\nThere is a magnitude of different asymmetric key security algorithms.\nRSA, DSA, and its Elliptic curve variant ECDSA are the pillars of modern\nsecurity solutions. However, the ﬂexibility of these schemes comes at an\nextra price of CPU cycles. All this makes these solutions inapplicable for\nsecuring data plane trafﬁc, but only rather to secure control plane. In\nwhat follows, just to underpin the beauty of the math behind asymmetric\nkey cryptography, we provide a description of the RSA algorithm.\nIn the RSA cryptosystem, the sender generates a pair of keys as fol-\nlows: First, the sender chooses large enough two prime numbers pand\nq. Next, the sender computes n=pqand evaluates Euler’s phi function:\n\u001e(n) = (p\u00001)(q\u00001). This is the same as the number of numbers co-prime\nton. The sender then selects at random encryption exponent esuch that\n1<e<\u001e (n)and alsoeshould be co-prime to \u001e(n). Finally, the sender or\nthe dealer computes the decryption exponent d, such that ed\u00111mod\u001e (n)\nusing modular multiplicative inverse (for that purpose extended Euclid-\nian algorithm can be used).\nThe public key is then (n;e), and the private key is (n;d). To encrypt the\nmessagemthe sender computes c=memodn . The decryption is similar\nm=cdmodn . The beauty is in Fermat’s little theorem, which states that\nm\u001e(n)mod n\u00111mod n . Now,ed\u00111mod \u001e (n), which means that ed=\nk\u001e(n) + 1 , and som(ed)modn\u0011m(k\u001e(n)+1)modn\u00111kmmodn\u0011mmodn .\nIn practice, RSA requires random padding to protect against such at-\ntacks as chosen ciphertext attacks and making two identical plaintexts\n11"
  },
  {
    "source": "vpls",
    "page": 12,
    "text": "Background\nproduce various ciphertexts. Padding also ensures that the message size\nis multiple of the encryption block-size. In practice, Optimal Asymmetric\nEncryption Padding (OAEP) scheme is used.\nIt is good to know that if the message is hashed and encrypted with\nthe private key, the result is a form of digital signature since the sender\ncannot later deny that it was involved in the encryption process. A Digi-\ntal Signature Algorithm (DSA) is another example of an asymmetric sig-\nnature scheme and was speciﬁcally designed for that purpose. In turn,\nElliptic Curves improve the performance of regular DSA algorithms.\nFrankly speaking, one-way functions can be also used to construct sig-\nnature schemes. For example, one can use one-time hash-based signa-\ntures to produce secure digital signatures. Nevertheless, the application\nof these types of signature algorithms is rather impractical and ﬁnds little\napplication in real-life settings.\n2.1.3 Cryptographic hash functions\nMathematically speaking, hash function is a special one-way function: For\na given pre-image of an arbitrary size it produces an image or hash value\nof a ﬁxed size, which is universally unique. Ideally, secure hash functions\nshould guarantee that the result it produces is irreversible. That it is, it\nshould be extremely hard to ﬁnd a pre-image or original message, given\nthe hash or the ﬁngerprint. Secure hash functions should be also collision-\nresistant. In other words, it should be extremely hard, if not impossible\nat all, to ﬁnd two different messages mandm0that will hash to the same\nvalue, i.e., hash (m) =hash (m0).\nSecure hash functions are important in modern cryptography. For ex-\nample, they can serve as authentication tokens for messages transmitted\nover the wire (useful, for example, in detecting message manipulation dur-\ning transmission), they also allow compressing the message before signing\nit with the digital signature algorithm, and, ﬁnally, they can be used to\nﬁnd the differences between the messages efﬁciently (useful in large ﬁle\ntransfer operations). The application area is of course broader than just\nthese few examples.\nHash functions come in different ﬂavors, but good ones should be com-\nputationally efﬁcient and resistant to collisions. Today, hash functions\nsuch as MD2, MD4 and MD5 considered broken, as there are works that\nshowed successful attacks. Brieﬂy speaking, researchers found collisions\nfor these hash functions. Therefore, it is not recommended to use these\n12"
  },
  {
    "source": "vpls",
    "page": 13,
    "text": "Background\nhash functions in security applications. A more modern family of SHA\nhash functions also exists. For example, engineers recommend to use\nSHA-256, SHA-512 and recent SHA-3 in modern applications, as no suc-\ncessful attacks were registered for these types of hash functions.\nHash functions pave the road for such a notion as authentication tokens\nwhen combined with a secret key in a special way. Examples are Hash-\nbased MAC (HMAC) [20], Parallelizable MAC (PMAC) [14], Cipher-based\nMAC (CMAC) which is based on AES cipher. For instance, by sending\nan HMAC together with the original message one can make sure that\nthe message will not be modiﬁed during the transmission. If, however,\nthe message will be altered on the route to a recipient, this fact will be\ndetected immediately during the veriﬁcation process.\nHash functions are also useful in signatures. For example, one-time sig-\nnatures use hash functions to construct a digital signature of a message.\nThey are, however, impractical as they require a considerable amount of\nstorage and can be used only one time as the name implies. An interested\nreader can ﬁnd more information about hash functions here [20].\n2.1.4 Key exchange protocols\nFinally, key exchange algorithms are also important in modern systems\nas they allow the negotiation of common keys over insecure channels. Of\ncourse, RSA can be used to deliver a session key by encrypting it with\nthe recipient’s public key, but specially crafted key negotiation algorithms\nexist in practice. Two bright examples are Difﬁe-Hellman (DH) and Ellip-\ntic Curve DH. Both DH and ECDH need to be authenticated in order to\nguarantee security.\n2.1.5 Post-quantum Lattice-based cryptography\nShor’s algorithm [18], implemented on a quantum computer, makes cer-\ntain computational problems (such as factorization of large numbers and\ndiscrete logarithm problems) feasible in polynomial time. This shutters\nthe security of the Internet, and so rigorous research was initiated to ﬁll\nthe gap. In what follows we discuss certain hard mathematical problems\non lattices and show the workings of the Learning With Errors (LWE)\npublic key encryption scheme [17]. In fact majority of NIST’s candidates\nfor post-quantum public key encryption algorithms are based on LWE.\nA lattice is a mathematical structure that consists of integers in ndi-\n13"
  },
  {
    "source": "vpls",
    "page": 14,
    "text": "Background\nmensions arranged in a structured lattice-like way. Mathematically, the\nlattice is deﬁned as follows:\n\u0003(B) =fBx;x2Zng\nwhere Bis a matrix of basis vectors that generates the lattice. We should\nnote that there exist a large number of basis vectors, some are good some\narebad.\nAclosest vector problem (CVP) on lattices, which is considered NP-\nhard, and believed unsolvable even on quantum computers, can be deﬁned\nas follows. Given a point t2Rnand a lattice \u0003(B), the task is to ﬁnd a\ncloses point Bxon lattice:\nmin\n8x2ZnkBx\u0000tk\nIn practice, the above problem is extremely hard to solve which makes\nlattice-based cryptography attractive to cryptographers.\nFrom linear algebra we know that solving equation Ax=bis simple\nusing Gaussian elimination. However, if a random noise is added to the\nequation\nAx+e=b\nthe problem is considered as hard as CVP on the lattice. Solving the above\nproblem directly relates to solving the CVP problem on lattice if the pa-\nrameters are selected carefully.\nSo, given a matrix A\u0018U(Znxm\nq), vector s\u0018U(Zn\nq)and vector e\u0018DZm;\u001b\nsampled from discrete (clipped) Gaussian distribution with parameter \u001b.\nWe require that, the probability P[e < q= 4]is high ( i.e.99:99%) to en-\nsure correct decryption of the message and to achieve the required level\nof security. We can deﬁne matrix A, secret key sand noise vector eas\nfollows:\nA=2\n666664a11a12a13::: a 1n\na21a22a23::: a 2n\n:::::::::::::\nam1am2am3::: amn3\n777775(2.1)\ns=2\n666664s1\ns2\n:::\nsn3\n777775(2.2)\n14"
  },
  {
    "source": "vpls",
    "page": 15,
    "text": "Background\ne=2\n666664e1\ne2\n:::\nem3\n777775(2.3)\nOnce the parameters are generated, we can compute As+e=b. Then,\nthe public key is (A;b)and the private key is s. Deriving sfrom bis a\nhard task at hand.\nTo encrypt the message \u00162f0;1g, we choose r\u0018U(f0;1gm). Then we\ncompute u=rAandv=rb+bq=2e\u0016. The ciphertext is (u;v). To decrypt\nthe message we can compute v\u0000us: if the result is close to 0output\n0, otherwise, if the result is close q=2output 1. For decryption to work\ncorrectly, we require that the parameter \u001b=q=(4m).\nThe major disadvantage of lattice-based cryptography is the size of the\nkeys and actual ciphertext. For example, the security of LWE depends\non two parameters nandq. By choosing n= 512 andq= 216, the size\nof ciphertext for a message of k= 256 bits long (for example, this is the\nsize of the key for AES-256 symmetric algorithm), will be O(k\u0001n\u0001logq)\u0019\n256\u000116\u0001512bits or roughly whooping 256KB. All in all the security does not\ncome for free. Of course, there are way much practical implementations of\nLWE-based encryption algorithms, for example, the reader can take a look\nat Kyber [16] which has a practical implementation in the TLS library.\n2.2 Security protocols\nEquipped with a basic understanding of cryptography we will now dive\ninto a discussion of some of the well-known security protocols, including\nIPSec, HIP, TLS, and SSH. All these protocols make a solid basis for se-\ncure internetworking.\n2.2.1 Host Identity Protocol (HIP)\nInternet was designed initially so that the Internet Protocol (IP) address\nhas a dual role: it is the locator, so that the routers can ﬁnd the recipient\nof a message, and it is an identiﬁer so that the upper layer protocols (such\nas TCP and UDP) can make bindings (for example, transport layer sockets\nuse IP addresses and ports to make connections). This becomes a problem\nwhen a networked device roams from one network to another, and so the\nIP address changes, leading to failures in upper-layer connections. The\n15"
  },
  {
    "source": "vpls",
    "page": 16,
    "text": "Background\nother problem is the establishment of an authenticated channel between\nthe communicating parties. In practice, when making connections, the\nlong-term identities of the parties are not veriﬁed. Of course, solutions\nsuch as SSL can readily solve the problem at hand. However, SSL is suit-\nable only for TCP connections, and most of the time, practical use cases\ninclude only secure web surﬁng and the establishment of VPN tunnels.\nHost Identity Protocol, on the other hand, is more ﬂexible: it allows peers\nto create authenticated secure channels on the network layer, so all upper-\nlayer protocols can beneﬁt from such channels. More on the protocol can\nbe found in [15].\nHIP relies on the 4-way handshake to establish an authenticated ses-\nsion. During the handshake, the peers authenticate each other using\nlong-term public keys and derive session keys using Difﬁe-Hellman or\nElliptic Curve (EC) Difﬁe-Hellman algorithms. To combat the denial-of-\nservice attacks, HIP also introduces computational puzzles.\nHIP uses a truncated hash of the public key as an identiﬁer in the form\nof an IPv6 address and exposes this identiﬁer to the upper layer protocols\nso that applications can make regular connections (for example, appli-\ncations can open regular TCP or UDP socket connections). At the same\ntime, HIP uses regular IP addresses (both IPv4 and IPv6 are supported)\nfor routing purposes. Thus, when the attachment of a host changes (and\nso does the IP address used for routing purposes), the identiﬁer, which is\nexposed to the applications, stays the same. HIP uses a particular sig-\nnaling routine to notify the corresponding peer about the locator change.\nMore information about HIP can be found in RFC 7401 [3].\n2.2.2 Transport Layer Security (TLS)\nSecure socket layer (SSL) [2] and Transport Layer Security (TLS) [5] are\nan application layer solutions to secure TCP connections. SSL was stan-\ndardized in RFC 6101. TLS was standardized in RFC 5246. And was\ndesigned to prevent eavesdropping, man-in-the-middle attacks, tamper-\ning, and message forgery. In SSL communicating hosts can authenticate\neach other with the help of longer-term identities - public key certiﬁcates.\nSSL is great for building VPN tunnels and protecting upper-layer proto-\ncols such as HTTP.\n16"
  },
  {
    "source": "vpls",
    "page": 17,
    "text": "Background\n2.2.3 Secure Shell Protocol (SSH)\nSecure Shell protocol (SSH) is the application layer protocol that provides\nan encrypted channel for insecure networks. SSH was originally designed\nto provide secure remote command-line, login, and command execution.\nBut in fact, any network service can be secured with SSH. Moreover, SSH\nprovides a means for creating VPN tunnels between spatially separated\nnetworks: SSH is a great protocol for forwarding local trafﬁc through re-\nmote servers.\n2.3 L2, L3 and L4 tunneling\nVirtual Private LAN Services (or VPLS), L3-VPNs, and L4 tunneling are\npretty standard nowadays. Companies build security solutions to provide\nLayer-2 and Layer-3 services for branch ofﬁces: VPLS are typically built\nas overlays on top of Layer-3 (IP) and are Ethernet over IP type overlays,\nwhereas L3-VPNs are IP-in-IP tunneling solutions.\nIn VPLS, when a frame arrives at VPLS provider equipment (PE), it is\nencapsulated into an IP packet and is sent out to all other VPLS network\nelements comprising emulated LAN. Security of such overlays is impor-\ntant for obvious reasons: customers do not want their corporate trafﬁc\nto be sniffed and analyzed. In L3-VPN networks, on the other hand, the\nnetworks form different broadcast domains, and so when an IPv4 or IPv6\npacket arrives at the VPN box, it is encapsulated in another IP packet and\nsent out using the backbone network. In this work, we built such secure\noverlays with Host Identity Protocol.\nIn this section, however, we will brieﬂy review some of the widely used\nsolutions for building L2, L3 and L4 overlays.\n2.3.1 Virtual Private LAN Services (VPLS) solutions\nIn this section we will cover to standard ways to build VPLS networks\n(using, for example, 802.1q QinQ tunneling and MPLS).\nQinQ tunneling\nWhen the path from one network to the other, such as branch ofﬁce to\nhead ofﬁce, traverses only layer-2 switches ( i.e.no IP routing is involved),\nthe VPLS can be organized with the help of 802.1Q protocol [12]. Broadly,\nspeaking this is not a protocol as such, but rather VLAN tag-based switch-\n17"
  },
  {
    "source": "vpls",
    "page": 18,
    "text": "Background\ning. Thus, on the ingress point, an additional 802.1q service provider SP-\nVLAN tag is inserted in the L2 header of an Ethernet frame. Later, the\nforwarding decisions are made using this SP-VLAN tag. On the egress\npoint, the SP-VLAN tag is removed and the original Ethernet frame is\nforwarded to the recipient based on the destination MAC address and, if\nexists, on the inner C-VLAN tag.\nIt should be noted that the conﬁguration of forwarding is a manual step.\nAlso, QinQ does not provide additional mechanisms to secure the cus-\ntomer’s trafﬁc, thus limiting the application domain of this solution.\nMPLS tunneling\nMulti-protocol label switching is a standard protocol for forwarding any\ntrafﬁc type. It is a layer 2:5solution that sits between the data link layer\nand the network layer.\nIn MPLS the packets are forwarded not using MAC or IP addresses,\nbut rather using labels, which are distributed by control protocol. Thus,\nwhen a frame arrives at the router the current label is popped, the new\nlabel is added and the frame is forwarded to the next hop router. The pro-\ncess continues until the frame reaches the destination network where it is\nrouted based on the original identiﬁers (IP addresses or MAC addresses).\nObviously, MPLS has label distribution protocol and label switching com-\nponents. MPLS is an ideal solution to create overlays ( i.e.L2 and L3\nVPNs).\n2.3.2 Virtual Private Network (L3-VPN) security solutions\nThe major drawback of QinQ and MPLS is that they do not offer encryp-\ntion and authentication of trafﬁc out-of-the box. Therefore, additional\nsteps needs to be taken to protect end-to-end trafﬁc. In this section we\nwill review PPTP, SSL-based VPNs, L2TP and IPsec tunnels.\nMultipoint to single point VPN\nMultipoint to single-head VPN is a standard way of organizing a VPN\nnetwork for an organization that has a single head ofﬁce and multiple\nbranch ofﬁces. In this setup, multiple branch ofﬁces are connected to a\nhead end. We show such a setup in Figure 2.1.\nThere are several protocols available for such an arrangement. Exam-\nples are: (i) Point-to-Point Tunneling Protocol (PPTP) [19]; (ii) Generic\nRouting Encapsulation (GRE) [19]; (iii) SSL-based Secure Socket Tunnel-\n18"
  },
  {
    "source": "vpls",
    "page": 19,
    "text": "Background\nFigure 2.1. Typical arrangement of the VPN\ning Protocol (SSTP); (iv) Layer 2 Tunneling Protocol (L2TP) [19], which\nis an older protocol that can be combined with IPSec for encryption; (v)\nInternet Protocol Security (IPSec).\nGRE on its own does not provide security and can be used together with\nIPsec to secure the trafﬁc. PPTP, in turn, does not provide strong secu-\nrity out of the box. PPTP uses weak Microsoft Point-to-Point Encryption\n(MPPE), which is considered insecure. PPTP combines GRE and PPP pro-\ntocols under a single umbrella. It is the PPP protocol [19] that provides\nsuch services as authentication (using MS-CHAPv2, PAP or strong EAP\nprotocol) and link conﬁguration ( i.e.using Link Control Protocol (LCP)).\nOverall, it is not recommended to use PPTP in modern VPN setups. L2TP\nwith IPSec AES-256 encryption is more secure alternative.\nSSTP protocol is built on top of existing SSL. It allows tunneling user\ntrafﬁc over protected channel, and yet the trafﬁc looks like normal HTTPS\ntrafﬁc to service providers. We have, ourselves, created a similar in spirit\nL3-VPN solution that is based on SSL [6]. The solution operates on a\nstandard HTTPS port. However, our idea is to tunnel all trafﬁc from VPN-\nagnostic hosts through the off-the-path black box that encrypts all trafﬁc\nand sends encapsulated in TCP and SSL packets to the L3-VPN head\nserver. The solution that we have created is a simple script that allows us\nto set up such an arrangement with no hassle. One drawback is that it\n19"
  },
  {
    "source": "vpls",
    "page": 20,
    "text": "Background\nuses TCP for transport: sending over a reliable TCP channel and over well\nknown HTTPS port is good for bypassing the trafﬁc ﬁlters, but reduces the\nperformance especially if the channel has a large latency and error rate.\nIPSec [19] comes in two variations: Authentication Header (AH) and En-\ncapsulating Security Payload (ESP). The ﬁrst does not encrypt the data-\nplane trafﬁc but rather adds HMAC to the packet. The second one, in\naddition to authentication, adds encryption of the payload. IPSec, when\ncombined with the key exchange protocols, such as Internet Key Exchange\n(IKE) [4], can be used to create secure tunnels between the sites.\nSSH tunneling\nSSH, despite that it was invented for remote access to Linux-like boxes,\ncan be used to tunnel local trafﬁc to remote machine and remote trafﬁc to\nlocal machine [13]. Thus, it can be used to create layer-4 tunnels. For ex-\nample, the following command will tunnel all local trafﬁc from port 4443\nto remote web-server youtube.com on port 443:\nssh -L 192.168.1.1:4443:youtube.com:443 user@strangebit.io\nIn this example, when the client types https://192.168.1.1:4443/ in\nthe browser window, the trafﬁc will be forwarded to the remote youtube\nserver through the SSH server strangebit.io .\nThere is also a possibility to perform reverse tunneling, i.e. one can\nexpose the local service to the world. For example, suppose you have a\nprecious MySQL resource in your local network running on host 192.168.\n1.45 on port 3306, then you can expose the service to the world using the\nfollowing command:\nssh -R 0.0.0.0:3306:192.168.1.45:3306 user@strangebit.io\nThis way various tunneling setups can be organized making SSH an\nattractive secure tunneling solution.\n20"
  },
  {
    "source": "vpls",
    "page": 21,
    "text": "3. Results\nIn this chapter, we are going to present the results that we have obtained\nthroughout the several years that we have spent building various sys-\ntems. We start with the results for the cryptographic library which we\nhave implemented to boost the performance of AES and HMAC algo-\nrithms on Intel CPUs. We then present the results for complete HIP-\nVPLS architecture and present the looking of the web interface which\nwas used to conﬁgure the HIP switches. Finally, we present the design\nand implementation of the hierarchical L3-VPN in the Mininet emulator.\n3.1 Hardware-enabled symmetric cryptography\nPart of the work that we have done was related to porting parts of the\ncode to pure C and special Intel CPU instructions. In this section, we will\ndescribe our achievements in this direction.\nFor the benchmarking, we have selected three implementations. The\nﬁrst one was pure Python based. For that purpose, we have used Py-\nCryptodome library. The second implementation was a Python wrapper\nto the C library that used special Intel CPU instructions to boost the AES\nand SHA-based HMAC operations. The third implementation was pure\nC library which was using Intel NI instructions. The results for AES-256\nand HMAC operations for varying block sizes are shown in Figure 3.1 and\nin Figure 3.2. The plots show the average running time in microseconds\nwith the 95% conﬁdence intervals.\nWhat does this mean to HIP-VPLS performance? For a standard packet\nof size 1500 bytes we have compared the performance (combined HMAC\nand AES-256) and it turned out, on one hand, that the implementation\nof cryptography in pure C with special CPU instructions was 12:1faster\nthan pure Python implementation. On the other hand, Python implemen-\n21"
  },
  {
    "source": "vpls",
    "page": 22,
    "text": "Results\n05101520\n0 500 1000 1500\nMessage size, BytesTime, us\nImplementations Hybrid Native Python\nFigure 3.1. AES-256 encryption (microseconds)\ntation with bindings to C library demonstrated performance which was\n2:3times faster. By making back of the envelop calculations we predict\nthat Python implementation can achieve roughly 461Mbit/s in upload and\ndownload directions cumulatively. However, in practice, given other oper-\nations with packets, we did not get this result in our experiments (more\nabout the performance of HIP-VPLS on real hardware can be found in the\nproceeding chapter). For the plain C implementation with AES and SHA\ninstructions, the performance will be better and constitute an astonish-\ning2:5Gbit/s. If someone needs to run the code in production the entire\ncode needs to be rewritten in plain C or Rust programming language for\nadequate performance.\n3.2 Host Identity Protocol based VPLS\nVirtual Private LAN Services (VPLS) provide means for building Layer 2\ncommunication on top of existing IP networks. As we have mentioned al-\nready, VPLS can be built using various approaches. However, when build-\ning a production-grade VPLS solution one needs to have a clear picture of\n22"
  },
  {
    "source": "vpls",
    "page": 23,
    "text": "Results\n010203040\n0 500 1000 1500\nMessage size, BytesTime, us\nImplementations Hybrid Native Python\nFigure 3.2. HMAC calculation (microseconds)\nhow such aspects as security and scalability will be solved.\nIn what follows, we will demonstrate how to build the VPLS using Host\nIdentity Protocol (HIP). Our initial goal was not to build a production-\ngrade implementation of HIP switches. Instead, at ﬁrst, we were only\ninterested in demonstrating proof of a concept solution in Mininet [1] –\na framework for emulating L2 and L3 networks. It is worth mentioning\nthat the code we have produced can be also deployed (under certain con-\nditions; for example, our HIP implementation does not feature the NAT\ntraversal mechanisms) on the real hardware in the Internet. We are going\nto demonstrate a working prototype in the later part of this work (here we\nassume that the public IPs are not from private range). All our prototypes\nuse Python-based HIP [11] as the bases.\nWhile building HIP switches (the switches that are deployed at the bor-\nder of a network and are responsible for setting up security associations\nand pseudowires) we came across several challenges. First, to avoid loops\nthe underlying network needs to support the IEEE 802.1D protocol (or\nits modiﬁcation - this really depends on the version of the protocol sup-\nported by the switches). This problem was initially addressed in the rele-\n23"
  },
  {
    "source": "vpls",
    "page": 24,
    "text": "Results\nvant IETF draft. For the sake of brevity, we note that if LAN implements\n802.1D STP protocol there will be no loops in the HIP-VPLS instance. Sec-\nond, there were certain issues with MTU and the inability of the Linux\nkernel to deliver IP packets when those are fragmented in user space and\ninjected into the network stack using raw sockets. And ﬁnally, it took us\nsome time to repackage the existing implementation of HIP protocol as a\nlibrary, so that it would be agnostic about low-level networking (such as\nraw sockets, etc.). In the proceeding paragraphs, we will demonstrate the\nusage of HIP-based VPLS using loop-free L2 topology.\nThe logical network diagram of our Mininet prototype is shown in the\nFigure 3.4.\nFigure 3.3. HIP-VPLS logical diagram (Mininet deployment)\nOur HIP-VPLS implemnetation [7] in Mininet was using static conﬁg-\nuration, meaning that HIP-VPLS mesh, resolver and ﬁrewall rules were\nconﬁgured prior to deployment of the overlay network and remained un-\nchanged throughout the experiments. An interested reader can take a\nlook at [7] for precise steps that are required to deploy the HIP-VPLS in\nthe Mininet environment.\nOverall, HIP-VPLS works as follows: (i) The daemon constantly listens\nfor packets on private interface and public interface; (ii) if the frame,\nwhich arrives on the private interface, is broadcast or multicast daemon\nchooses all HIP-VPLS peers in mesh to send the packet; (iii) if the frame\nis unicast and HIP security association exists for the destination daemon\nsends the packet to the selected HIP switch; (iv) if no security association\nexists HIP switch triggers HIP base exchange to negotiate secret keys\nand to establish security association; (v) If the IPSec packet arrives on\n24"
  },
  {
    "source": "vpls",
    "page": 25,
    "text": "Results\nthe public interface, ﬁrst HMAC is veriﬁed, and if it is valid the packet is\ndecrypted; the original Ethernet frame is then reinjected into the private\ninterface and regular destination MAC-based and VLAN-based forward-\ning is performed to deliver the frame to the recipient.\nOur HIP switch also implements the MAC learning and aging function-\nality: whenever a frame arrives on the public interface the HIP-switch\nnotes the source MAC address and adds it to the local database. Later,\nwhen a unicast frame arrives on the private interface, it looks up the\ndestination MAC address and chooses the corresponding HIP association\nand pseudowire to send the frame encapsulated into an IPSec packet to\nthe recipient.\nFigure 3.4. HIP-VPLS logical diagram (real hardware deployment)\nTo get a grasp on the performance of HIP-VPLS in the Mininet envi-\nronment we have performed a series of bandwidth tests using iperf tool.\nTo run the experiments we have used the UTM emulator (installed on\nMacBook M1) with Ubuntu 22.04 installed. All in all the results were the\nfollowing: the 95% conﬁdence interval for sample mean throughput was\n58:9\u00060:52Mbit/s.\nWe now turn our attention to the real-life deployment of HIP-VPLS [8,\n9]. The system architecture is similar to our Minent prototype (except\nthat there was a lesser number of HIP switches) shown in Figure 3.4.\nApart from the HIP-VPLS switches, we have also implemented a unique\ncontrol-plane protocol on top of the SSL protocol for communication with\nthe central controller on the Internet.\nIn our deployment, we have used the following setup. For HIP switches\nwe have used the dual-network Intel N95 computing platform. We have\n25"
  },
  {
    "source": "vpls",
    "page": 26,
    "text": "Results\nused 8port SNR switch to connect 3HIP switches, that way we have\nmimicked the IP overlay in the setup. HIP switches had two interfaces:\none was facing LAN network, the other one was facing the WAN network.\nThe microcomputers for HIP switches had the following characteristics:\nthey had 8GB of RAM memory, quad-core Intel N95 CPU (with support\nfor AES and SHA2 NI instructions), 256GB of solid state hard drive. To\nwire the routers we have used SNR switches (each switch had 8 1Gbit/s\nports and two Small Form Factor (SFP) slots). The testbed conﬁguration\nis shown on Figure 3.6.\nIn the testbed, we had a multihomed server (with one IP facing the pub-\nlic network so that HIP switches will be able to connect to the controller\nin the Internet, and one IP in the private range; this server was playing\nthe role of HIP controller), several legacy microcomputers, IP camera, and\nDHCP and DNS servers.\nIn our testbed the central controller was responsible reporting the live-\nness of HIP switches as well as provisioning the devices with the mesh\nconﬁguration information, ﬁrewall rules and MAC-based ACL. For that\npurpose, we developed a simple secure protocol which was utilizing TLS.\nFor example, consider the Figure 3.5 which shows the HIP switch regis-\ntration and status information.\nFigure 3.5. HIP-VPLS central controller UI\nAccording to the protocol, on the one hand, every HIP-VPLS the switch\nwas reporting to the central controller (all requests were authenticated\nusing the HMAC algorithm together with the shared symmetric master\nsecret). In the implementation, switches were reporting their presence ev-\n26"
  },
  {
    "source": "vpls",
    "page": 27,
    "text": "Results\nery5seconds. On the other hand, every HIP-VPLS switch was obtaining\nthe conﬁguration from the central controller (such as mesh conﬁguration,\nHIT resolver information, ﬁrewall rules, and MAC-based ACL).\nFigure 3.6. Testbed\nTo conclude we have performed a series of real-life experiments to mea-\nsure the performance of the HIP-VPLS network. In Table 3.1 we show\nsample statistics for upload and download throughput. In addition, we\nhave also measured latency. To perform the measurements we have used\nspeedtest Python library. Thus, on one side, we have connected the Mac-\nBook to the HIP switch via a regular switch. On the other side, we have\nconnected the other HIP switch to a network that had connectivity to\nthe Internet. We then performed 100rounds of measurements, collected\nthroughput and latency data and processed the cleaned data using Python\nstatistics library.\n27"
  },
  {
    "source": "vpls",
    "page": 28,
    "text": "Results\nStatistics Upload (Mbit/s) Download (Mbit/s) Latency (ms)\nSample mean 46:1 48:2 5:0\nSample std 7:1 2:3 0:19\nSample median 44:8 48:8 4:9\nSample min 14:3 40:0 4:6\nSample max 61:3 50:4 5:4\nTable 3.1. Performance of HIP-VPLS on Intel N95 CPU\n3.3 Scalable multipoint to multipoint VPN using HIP protocol\nThe major problem with the HIP-VPLS is the number of HIP switches\nand full-mesh connectivity between these switches. Imagine that there\nare not 10s, but 1000s sites, and that all sites need to be combined into\na single network. First of all, there will be O(n2)pseudo-wires: for 1000\nPEs there will be around 1M of routing table entries. Second, HIP-VPLS\nprovides a single broadcast domain. And so there is going to be chaos\nin the network which will be overwhelmed with broadcast and multicast\nEthernet frames. All these aspects make this type of arrangement of net-\nwork unacceptable in the aforementioned scenarios. Instead, what if we\nlet each site live in its own broadcast domain, i.e.have a separate network\naddress, and combine through a series of overlay routers, which will be re-\nsponsible for forwarding the packets between the networks (sites) based\non inner IPv4 addresses.\nTo make the network scalable and reduce the number of pseudowires we\nlet some nodes play the hub role, that is they will be the backbone of the\noverlay network. While some nodes will be the spoke nodes and will be\nconnected directly to the sites. It is the hierarchy that makes the network\nscalable.\nIt is logical to ask why would someone need to build the multipoint to\nmultipoint L3-VPN? Well, hub-and-spoke architecture adds reliability to\nthe system: if one node will fail, the entire network will not. It is, there-\nfore, suggested to build the hub-and-spoke type of L3-VPN if high depend-\nability of an overlay is a must.\nIt is worth to look at the overall architecture which we have imple-\nmented in Mininet framework [10]. The logical diagram is shown in Fig-\nure 3.7. As we have already mentioned, the architecture of the distributed\nL3-VPN network is of hub-and-spoke type. Hub nodes comprise the back-\nbone of the network, whereas, multiple spoke PE elements are attached\n28"
  },
  {
    "source": "vpls",
    "page": 29,
    "text": "Results\nto the hubs.\nThe security of the network is achieved by using Host Identity Proto-\ncol (on a hop-by-hop basis) to negotiate the authentication and encryption\nkeys, whereas, the actual packet authentication and encryption is per-\nformed on hop-by-hop bases using HMAC-SHA256 and AES (with 256\nbits key) algorithms. In our prototype implementation we have populated\nthe routing tables manually, however, in practice this process should be\nautomated using for example central controller.\nFigure 3.7. HIP-based L3-VPN in Mininet\nTo get the taste of the performance of this setup we have performed\nseveral rounds of experiments with the iperf utility and measured the\nthroughput with encryption/authentication enabled. The results are the\nfollowing: 19:7\u00060:06Mbit/s. This was expected, since the packet is de-\ncrypted and encrypted, as well as HMAC is recalcutated at every hop on\nthe path from source CE to destination CE. Perphas, hop-by-hop encryp-\ntion and authenication can be done selectively with global secret key so\nthat better performance can be achived.\n3.4 Comparison of various solutions\nIn what follows, we compare now different approaches and identify their\ncharacteristics and limitations. In Table 3.2 we compare three different\n29"
  },
  {
    "source": "vpls",
    "page": 30,
    "text": "Results\nCharacteristic#Overlay type! L2-VPLS L3-VPN HIP-VPLS\nSize of forwarding/routing table O(n) O(m) O(n)\nNumber of links in mesh O(k2) O(k2) O(l2)\nPrivacy (exposure of information) MACs IPs No\nEncryption and authentication Hop-by-hop Hop-by-hop PE-to-PE\nTunneling mode Ethernet-in-IP IP-in-IP Ethernet-in-IP\nLoop free-topology 802.1D/Controller Controller Not required\nTable 3.2. Comparison study of different multipoint VPLS/VPN designs\napproaches for building overlays with Host Identity Protocol. The ﬁrst\none is scalable L2-VPLS with hub-and-spoke architecture. The second\none, L3-VPN, also with hub-and-spoke design. And ﬁnally, we have HIP-\nVPLS at our disposal with full mesh connectivity of provider equipment\n(PE).\nThe ﬁrst characteristic is the size of the forwarding table on the PE\nelements. For L2-VPLS and L3-VPN it is equal to O(n), wherenis the\nnumber of regular hosts in the network. This is obvious, as the MAC\naddress table at least on the edge needs to know the mapping for each\nand every host in the network (consider when all hosts talk to all other\nhosts). For L3-VPN the size is considerably smaller since the routing table\ncontains only IP preﬁxes of the networks and so equals to O(m), wherem\nis the number of sites, hence, the size of the network address preﬁxes. The\nreader should understand that n\u001dm.\nThe second important characteristic is the number of links in a mesh\nnetwork. For L2-VPLS and L3-VPN it is equal to O(k2), wherekis the\nnumber of hub PEs. For HIP-VPLS this metric is equal to O(l2), such\nthatlis the overall number of sites or PEs. Clearly, l\u001dk, and hence the\nL3-VPN achieves better scalability.\nWhat about privacy? Well in scalable L2-VPLS and L3-VPN the MAC\nand IPs are exposed to intermediate hubs (at the end these addresses\nare used for forwarding). And so if a hub gets compromised this infor-\nmation will be leaked to the adversary. In turn, in HIP-VPLS there are\nno intermediate nodes in the network since the pseudowires are created\nend-to-end, and so there is no risk that the customer will expose sensitive\ninformation to intermediate nodes. Also, in scalable L2-VPLS and scal-\nable L3-VPN the encryption and authentication is done in a hop-by-hop\nmanner; whereas, in HIP-VPLS the encryption is PE-to-PE (or site-to-\nsite).\n30"
  },
  {
    "source": "vpls",
    "page": 31,
    "text": "Results\nOne last important point is the avoidance of loops in the network. For\nL2-VPLS loop-free topology is achieved with 802.1D protocol (PE should\nimplement this functionality, because they perform forwarding tasks) or\nan SDN central controller. In L3-VPN the loops are avoided with the\nhelp of the IP TTL ﬁeld. Also, in L3-VPN the routing tables are con-\nstructed centrally and no routing loops will exist in the topology. HIP-\nVPLS archives loop-free topology by assuming that customer networks\nrun an instance of STP protocol. There is no need to implement 802.1D\nSTP protocol for HIP switches since they do not forward Ethernet frames\n(received from public interface) to all, but private interface.\n31"
  },
  {
    "source": "vpls",
    "page": 32,
    "text": "Results\n32"
  },
  {
    "source": "vpls",
    "page": 33,
    "text": "4.Conclusions\nWe started this work with the background material on cryptography. Here\nwe covered established approaches (building blocks) of modern security\nprotocols. In addition, we have introduced to the reader more recent de-\nvelopments, such as the LWE encryption scheme. We see that integration\nof LWE encryption and signature algorithm into HIP protocol can be fu-\nture work. We then discussed how to build various secure tunnels, e.g.\nwith SSL, IPSec, and SSH protocols. We covered brieﬂy QinQ tunneling\nand MPLS protocol.\nIn the results section, we covered the results for various cryptographic\nlibraries, including the library which uses Intel NI instructions designed\nto boost the AES and HMAC. We concluded that the Python library with\nC-bindings is not enough for the production setup, and suggested imple-\nmenting the HIP-VPLS in Rust or C language. We then moved to the de-\nsciption of scalable L3-VPN and HIP-VPLS solutions. We concluded the\nwork with a comparison of various characteristics of scalable L2-VPLS,\nL3-VPN and HIP-VPLS solution.\n33"
  },
  {
    "source": "vpls",
    "page": 34,
    "text": "Conclusions\n34"
  },
  {
    "source": "vpls",
    "page": 35,
    "text": "Bibliography\n[1] Mininet: An Instant Virtual Network on your Laptop. https://mininet.org/.\n[2] RFC 6101: The Secure Sockets Layer (SSL) Protocol Version 3.0.\nhttps://datatracker.ietf.org/doc/html/rfc6101.\n[3] RFC 7401: Host Identity Protocol Version 2 (HIPv2). https://www.rfc-\neditor.org/rfc/rfc7401.html.\n[4] RFC 4306: Internet Key Exchange (IKEv2) Protocol, https://datatracker.\nietf.org/doc/html/rfc4306 . Online, 2005.\n[5] RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2.\nhttps://datatracker.ietf.org/doc/html/rfc5246, 2008.\n[6] Bypassing Deep Packet Inspection: Tunneling Trafﬁc\nOver TLS VPN https://www.linuxjournal.com/content/\nbypassing-deep-packet-inspection-tunneling-traffic-over-tls-vpn .\nOnline, 2021.\n[7] Simulating Host Identity Protocol-Based Virtual Private LAN Service Us-\ning Mininet Framework. https://www.linuxjournal.com/content/simulating-\nhost-identity-protocol-based-virtual-private-lan-service-using-mininet-\nframework, 2022.\n[8] HIP-VPLS. https://github.com/strangebit-io/hip-vpls-hw-with-controller,\n2023.\n[9] HIP-VPLS controller. https://github.com/strangebit-io/hip-vpls-controller,\n2023.\n[10] HIP-based L3-VPN. https://github.com/dmitriykuptsov/hip-vpls-routing,\n2024.\n[11] Python-based Host Identity Protocol, https://github.com/\ndmitriykuptsov/cutehip . Online, 2025.\n[12] SNR S2980G-8T Switch Conﬁguration Guide, https://snr.systems/site/\ndata-files/SNR%20Switches/Configuration%20Guide/SNR-S2980G-8T%\n20Configuration%20Guide%20v1.0.pdf . Online, 2025.\n[13] SSH Tunneling, https://www.ssh.com/academy/ssh/tunneling . Online,\n2025.\n35"
  },
  {
    "source": "vpls",
    "page": 36,
    "text": "Bibliography\n[14] B LACK , J., AND ROGAWAY , P. A block-cipher mode of operation for\nparallelizable message authentication. In Proceedings of the Interna-\ntional Conference on the Theory and Applications of Cryptographic Tech-\nniques: Advances in Cryptology (Berlin, Heidelberg, 2002), EUROCRYPT\n’02, Springer-Verlag, p. 384–397.\n[15] G URTOV , A.Host Identity Protocol (HIP): Towards the Secure Mobile Inter-\nnet. 2008.\n[16] N ATIONAL INSTITUTE OF STANDARDS AND TECHNOLOGY . FIPS 203:\nModule-Lattice-Based Key-Encapsulation Mechanism Standard, 2024.\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.pdf .\n[17] R EGEV , O. The learning with errors problem (invited survey). In Proceed-\nings of the Annual IEEE Conference on Computational Complexity (2010),\npp. 191–204.\n[18] S HOR, P. Algorithms for quantum computation: discrete logarithms and\nfactoring. In Proceedings 35th Annual Symposium on Foundations of Com-\nputer Science (1994).\n[19] S TEVENS , W. R. TCP/IP illustrated (vol. 1): The Protocols . Addison-Wesley\nLongman Publishing Co., Inc., USA, 1993.\n[20] S TINSON , D. Cryptography: Theory and Practice, Second Edition , 2nd ed.\nCRC/C&H, 2002.\n36"
  },
  {
    "source": "analysis",
    "page": 1,
    "text": "Iluminating a small network: Perspec-\ntive from within\nStrangeBit\n2026"
  },
  {
    "source": "analysis",
    "page": 2,
    "text": "2"
  },
  {
    "source": "analysis",
    "page": 3,
    "text": "Contents\nContents 3\n1. Introduction 5\n1.1 Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2. Background 7\n2.1 Basic network characteristics . . . . . . . . . . . . . . . . . . 7\n2.2 Topologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.3 Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.4 Network protocols to watch out for . . . . . . . . . . . . . . . 12\n2.4.1 Spanning trees . . . . . . . . . . . . . . . . . . . . . . 12\n2.4.2 TCP, UDP and ICMP . . . . . . . . . . . . . . . . . . . 13\n2.4.3 DNS and DHCP . . . . . . . . . . . . . . . . . . . . . . 15\n2.4.4 LDAP and other Windows services . . . . . . . . . . . 15\n2.4.5 What about timing: NTP . . . . . . . . . . . . . . . . . 16\n2.4.6 SSH, TLS and other security protocols . . . . . . . . . 16\n2.4.7 Watch out for anti-virus . . . . . . . . . . . . . . . . . 17\n3. Results 19\n3.1 Data collection . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.2 Breakdown of the network protocols in small enterprise net-\nwork . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n3.3 Watch out! We are plotting the network map . . . . . . . . . 24\n3.4 Performance, performance and once again performance: Stress-\ning the network . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n3.5 VPN connections . . . . . . . . . . . . . . . . . . . . . . . . . 26\n4. Conclusions 29\nBibliography 31\n3"
  },
  {
    "source": "analysis",
    "page": 4,
    "text": "Contents\n4"
  },
  {
    "source": "analysis",
    "page": 5,
    "text": "1.Introduction\nMeasurements and troubleshooting are two important tasks that network\nengineers and administrators carry out quite often. To be able to maintain\nnetwork in healthy conditions engineers need to perform monitoring of\nthe network every now and then. But monitoring is not the only task.\nEngineers also need to troubleshoot the network quite often. For that\nmatter, in the paragraphs that follow we discuss basic network tools and\ntechniques which can be used to measure and debug the network.\n1.1 Questions\nIn this section we enumerate research questions that we would like to\nanswer in this report. We foresee at least three important questions in\nthis report. Namely those are: (i) What to measure in the enterprise\nnetworks? By answering this question we attempt to shed the light\non most important characteristics in the network trafﬁc analysis. Be it\nlatency, throughput, goodput, error and loss rate, availability. (ii) How\nto measure? Here we would like to answer how to perform the net-\nwork measurements. For example, how to select vantage point, how to\nminimize the dataset, but still be able to grasp the most important char-\nacteristics of the network. (iii) When to measure? This question is also\nimportant for a number of reasons. Selecting correct measurement period\nand correct duration of the measurements intervals will have the impor-\ntant impact on the quality of the research outcome.\nBy answering these questions properly one can illuminate the perfor-\nmance of the networking infrastructure. Note, in this work we are con-\nsidering only small networks, comprising 10-100 devices. However, we\nbelieve that these questions are also applicable to larger networks and\nmore complicated topologies.\n5"
  },
  {
    "source": "analysis",
    "page": 6,
    "text": "Introduction\n6"
  },
  {
    "source": "analysis",
    "page": 7,
    "text": "2. Background\nThis section consists of several important parts: First, we discuss main\ncharacteristics of the network; Second, we describe various types of net-\nwork topologies and device orchestrations; Third, we present various tools\nwhich are useful in enterprise network measurements; Finally, we discuss\nmost widely spread network protocols to watch out for in the enterprise\nnetwork trafﬁc.\n2.1 Basic network characteristics\nWe believe that there are several key network characteristics: delay, jitter,\nthroughput, goodput, error and loss rates. All these metrics can be used\nto measure the performance of the networked systems. In the paragraphs\nthat follow we will describe these metrics and try to explain why they are\nso important.\nDelay is the time it takes for the packet (on network layer) to reach the\nother communication side. Delay can be one way or two way, also called\nround trip time . The former one is hard to measure since the clocks on\nboth sides need to be synchronized. Technically, of course we can use so-\nphisticated algorithms and packet trains to measure one way delay (for\nexample, the reader can look at the RFC 7679 [2]). But most of the time\npeople rely on half of the RTT. This metric is less accurate since the pack-\nets can travel different paths and, hence, delays can be different. But yet\nthis metric is quite common. For example, ping utility reports RTT as\nthe measure of delay. We should note that delay impacts user experience\ngreatly, and therefore, it is good to have links with low delays.\nJitter is yet another important metric and is widely spread across net-\nwork engineers. Jitter is the variation of the delay, that is jitter shows\nhow much the delay is varying throughout time. This metric is important\n7"
  },
  {
    "source": "analysis",
    "page": 8,
    "text": "Background\nbecause it can affect how the protocol timers are calculated. For example,\nif the jitter is high, the calculated timers can be inaccurate and, hence,\nthe performance of such protocols can be undermined. Thus, the lower\nthe jitter the better, in authors opinion, the performance of the networked\ndevices. One easy way to compute jitter is to build the histogram of the\nnetwork delays and compute the variance.\nThroughput is also important and it captures how much data (including\nprotocol headers and user payload) can be delivered throughout network\nsystem in predeﬁned time interval. Typically, the throughput is measured\nin Kb/s, Mb/s and Gb/s. Obviously, the larger is the throughput the bet-\nter network operates. Networks with large throughput can service larger\nnumber of clients. Goodput is the same as throughput, but excludes the\ncontrol data from the calculations. In other words, packet header is ex-\ncluded from the calculations and only user’s payload is considered.\nError rate describes how often the packets arrive at the receiver with\nthe corrupted bits. Most of the protocols use notion of reliability (that is\nif the data is corrupted it is requested again) and, hence, high error rate\ncan reduce the performance of such protocols considerably. It is therefore\nimportant for the network engineers to avoid highly unstable links. Dif-\nferent media and operational environments have different error rates. For\nexample, wireless links often have grater error rate than wired and opti-\ncal links. Also, different applications have different tolerance to errors.\nFor example, Voice over IP and Video over IP require error rates to be low.\nMail systems, on the other side, can tolerate high error rates, because the\nsystem works in the background and corrupted packets can be requested\nagain.\nLoss rate is the ﬁnal metrics that we will cover. Loss occurs, for ex-\nample, when intermediary routers drop the packet because of congestion\nor corruption of the packet. Once again, similar to error rates, sensitive\napplications do not operate well in lossy environments. Hence, typically,\nnetwork engineers design systems so that such applications will use links\nwith little loss, while other trafﬁc such as HTTP and SNMP protocols\ncan use less expensive, but yet, lossy links. Typically, wireless links with\nweak signal, for example, have higher loss rates than fat wired and optical\nlinks.\nThere are also other characteristics that can be measured, for example,\nthe reader can take a look at the congestion and some other. But we are\nnot going to cover those in this report.\n8"
  },
  {
    "source": "analysis",
    "page": 9,
    "text": "Background\n2.2 Topologies\nThere are several key topologies that are used in enterprises: mesh, star\nand hybrid. Mesh topology is such topology in which every network ele-\nment is connected to every other network element. The links can be wired,\nwireless and pseudo links (if we are talking about overlays). Mesh can be\nfull and partial. In full mesh, obviously, every element is connected every\nother element in the network. Consider, for example, personal area net-\nwork in which all nodes are connected using wireless medium. Wired\nmeshes are expensive, though, and are rarely used in modern deploy-\nments. Meshes are crucial, however, when availability is a must. In mesh,\nsome nodes can fail, yet, the network will remain alive and packets will\nbe delivered, not to all, but some devices at least. A typical mesh network\ntopology is shown in Figure 2.1.\nFigure 2.1. Mesh topology\nStar topologies are cheaper and less fault tolerant. In star-like topology\none node becomes the root, while others connected to the root element and\nall the trafﬁc ﬂows through it. Oftentimes, redundant links are added to\nthe topology to bring some level of tolerance to failures. A typical star\ntopology is shown in Figure 2.2.\n9"
  },
  {
    "source": "analysis",
    "page": 10,
    "text": "Background\nFigure 2.2. Star topology\nFinally, there are also hybrid topologies, such as hub-and-spoke net-\nworks. In this type of networks spoke nodes are connected to hubs, while\nhubs form a full mesh between each other. Such networks are cheaper\nthan full mesh, but more fault tolerant than star topologies. A typical\nnetwork is shown in Figure 2.3.\nFigure 2.3. Hub-and-spoke topology\n10"
  },
  {
    "source": "analysis",
    "page": 11,
    "text": "Background\n2.3 Tools\nNetwork engineers use wide variety of tools for measuring the perma-\nnence of the networks and in debugging tasks. All tools can be catego-\nrized based on tasks they are meant to be used for, such as, measuring\nand troubleshooting.\nMeasurement tasks: to measure performance of the network a common\nset of tools includes ping utility, tcpping utility, traceroute utility, nc tool,\nspeedtest and iperf, snmp statistics reports by agents and direct queries.\nIn the following paragraph we will describe these tools.\nPing utility is the most common tool to measure reachability of a host\nand measure the round trip times. The tool is based on the ICMP pro-\ntocol which we will describe later. This tool is widely available in Linux,\nWindows, BSD and Unix operating systems.\nTCPing is another common network tool to measure the reachability of\nthe TCP port in the network. But the tool can be also used to measure\nthe time to establish a TCP connection. To our best knowledge this tool is\nwidely available for Windows OS without any charges.\nspeedtest and iperf utilities were primarily designed for measuring the\nbandwidth between two systems. The later one has client and server im-\nplementations. This means that to measure the bandwidth (both UDP\nand TCP connections can be used) one needs to start ﬁrst the server with\nthe -s ﬂag, and only then run the client with -c ﬂag.\ntreceroute is used often to trace the path the packet takes from host A\nto host B. The tool uses ICMP under the hood. Not only it is used to trace\nthe reachability of the intermediate routers but it also reports the RTTs.\nnetcat, or nc is the tool that is available in Linux distributions and com-\nmonly used to send the commands to the server over UDP sockets. It can\nbe used to measure the bandwidth. For example, network administrators\ncan send large enough binary package to the server and measure the time\nit takes for the transmission to happen.\nAnd ﬁnally SNMP can be used to collect reports from agents about net-\nwork performance. Such characteristics as bytes per second delivered by\nthe network interface, ping RTT and many more can all be collected from\nnetwork devices either with direct queries or with the help of agents.\nTroubleshooting . A set of tools available in this category are: nmap, tcp-\ndump, Wireshark, nslookup, dig, iproute, and ifconﬁg. All these tools are\nindispensable in analyzing and troubleshooting the network problems. It\n11"
  },
  {
    "source": "analysis",
    "page": 12,
    "text": "Background\nis essential for any network engineer to be acquainted and actively apply\nthese tools. In the paragraphs that follows we will describe what every\ntool means, but brieﬂy.\nnmap is a tool that allows network engineer to detect open network ports\n(both UDP and TCP). Essentially, the tool scans the remote system and\nreports which port is open. Network engineers and hackers actively use\nthis tool to detect weak points in the network systems.\ntcpdump and Wireshark . These tools are helpful in collecting and an-\nalyzing network protocols. tcpdump is typically used to collect the raw\npackets and frames from the network interface of interest, while Wire-\nshark is more advanced: it can analyze the network trafﬁc and export\nit to XML and JSON ﬁle formats. We ourselves use these tools in our\nnetwork trafﬁc analysis tasks.\nnslookup and dig are used to detect the problems with the DNS servers\nand queries. These tools are often used by network engineers to detect\nthe problems with DNS and get information about remote systems.\niproute is a tool that can be used for multiple purposes, but primarily\nthese tools are useful in conﬁguring the routes to remote systems. For\nexample, network engineers can use the tool to check whether the routes\nto remote hosts exist. It can be also used to add static routes. But these\nare just few examples.\nAnd ﬁnally, ifconﬁg tool can be used to conﬁgure the network interfaces.\nFor example, network engineers can use this tool to set default gateway,\nIP address on the interface, and set the DNS server IP address, either\nmanually or with help of DHCP server.\n2.4 Network protocols to watch out for\nThere is humongous amount of protocols in modern networks: from L2\nSTP to Voice of IP at L4. But we are interetested in only few protocols that\none should watch out during basic network analysis and troubleshooting:\nWe will cover L2 STP protocol, TCP, UDP, ICMP, DNS, DHCP and some\nsecurity protocols at L4 such as SSH and TLS.\n2.4.1 Spanning trees\nSpanning tree protocol or STP is one of the most important protocols in\nlocal area networks. STP builds a tree without loops so that frames will\n12"
  },
  {
    "source": "analysis",
    "page": 13,
    "text": "Background\nnot loop forever in the network.\nSpanning tree protocol operates on the L2 and is responsible for con-\nstructing the loop-free network topologies. Recall, L2 frames do not have\nTTL ﬁelds like IP protocol. And so if the network is not loop-free the\nframes can circulate endlessly in the network.\nSTP operates in phases. First, the network switches elect the so called\nroot bridge - the bridge that will be the root of the tree. Switches do so\nby broadcasting their identiﬁers - the switch with the lowest identiﬁer is\nelected as root. Once, the root switch is elected nodes start to construct\nthe tree by assigning roles to the ports: the port can be either root port,\ndesignated port or blocked port. The root bridge assigns all of its ports as\ndesignated ports. Other switches assign ports as root ports if they have\nthe shortest distance to the root bridge. The switch assigns the remaining\nports as designated ports if they are closer too root port on the segment.\nThe remaining ports become blocked and so no trafﬁc can traverse these\nports. The initial implementation was deﬁned in IEEE 802.1D standard.\nLater more efﬁcient protocols were deﬁned for example consider Rapid\nSTP, Per VLAN STP. These protocols have faster convergence time and\ncan be used to deﬁned different spanning trees for each VLAN.\n2.4.2 TCP, UDP and ICMP\nThere are variety of the protocols on transport layer. But we are going to\ncover only three such protocols: TCP, UDP and ICMP.\nTCP protocol is the transport layer protocol. Transmission control proto-\ncol, or TCP, uses acknowledgments to deliver the packets in the network.\nIn other words TCP is a reliable protocol, since unacknowledged packets\nare being sent again. Many application layer protocols use TCP for trans-\nport. For example, SSH, HTTPS, FTP and other all use TCP as the base,\nsince these protocols do not tolerate packet losses.\nTCP session starts with 3-way handshakes. First the initiator, or client,\nsends SYN packet. Upon reception of the SYN packet the server sends\nthe SYN+ACK packet. And ﬁnally, the client acknowledges the reception\nof the SYN+ACK with ACK packet. During the handshake the parties\nalso exchange the initial sequence numbers between each other. The com-\npletion of the communication session happens with two-way handshake.\nOne party sends FIN packet and the other sends FIN+ACK packet.\nTCP protocol requires two IP addresses and two ports. There exist well\ndeﬁned ports for common TCP applications. It is important to look for\n13"
  },
  {
    "source": "analysis",
    "page": 14,
    "text": "Background\nthese well known ports during the trafﬁc analysis. In Table 2.1 we list\nsome of the well known TCP ports.\nTable 2.1. Well-known TCP ports\nProtocol Ports\nFTP 20/21\nSSH 22\nTelnet 23\nSMTP 25\nDNS 53\nHTTP 80\nPOP 110\nIMAP 143\nHTTPS 443\nLDAP 389\nUser Datagram protocol or UDP does not guarantee reliable delivery of\nthe packets. So, typically it is used together with such protocols as VoIP,\nDynamic Host Conﬁguration Protocol (DHCP). And redundancy is typi-\ncally embedded into the UDP protocol by the upper layer protocols. And\nin case of loss or corruption, upper layer protocols use this redundancy to\nmask these failures. UDP, however, similarly to TCP protocol uses port\nnumbers to make the connections. Retransmissions are also controlled by\nthe application itself.\nMost important UDP protocols and ports are shown in Table 2.2.\nTable 2.2. Well-known TCP ports\nProtocol Ports\nDNS 53\nDHCP 67/68\nSNMP 161\nTFTP 69\nRTP dynamic\nNTP 123\nSIP 5060\nQUIC 443\nInternet Control Message Protocol is typically used to detect liveness of\nthe hosts in the Internet, as well as to send error messages to the sender.\n14"
  },
  {
    "source": "analysis",
    "page": 15,
    "text": "Background\nICMP used in such utilities as ping and traceroute.\n2.4.3 DNS and DHCP\nDNS protocol or Domain Name Service protocol is used to resolve fully\nqualiﬁed domain name (FQDN) into IPv4 and IPv6 addresses. It is also\nused to perform reverse transformation from IP address to domain name.\nDNS is vital in modern network as it allows not to remember the IP ad-\ndress of the system, but, instead, human readable name of the resource.\nDNS resolver works recursively and iteratively. Thus, iterative resolver\nworks as follows: At ﬁrst, host sends the query to designated DNS server\n(typically the same machine as the default router or a dedicated DNS\nserver); Second, DNS server sends the query to the root; root domain\nserver responds with the Top Level Domain (TLD) server IP responsible\nfor the name in the query, and DNS server sends next query to TLD DNS\nserver; Finally, the DNS server sends the query to target DNS server and\nresolves the FQDN into IPv4 or IPv6 address.\nDynamic Host Conﬁguration Protocol is a handy protocol that allows\nconﬁguring hosts with IP address (both IPv4 and IPv6 versions exist),\ndefault gateway, DNS server and other parameters. DHCPv4 operates in\n4 phases (or 4-way handshake). First, the client send DISCOVER packet\n(broadcast) seeking for the DHCP server. DHCP server responds with\nthe OFFER (it offers IP address). Later on the client, if it accepts the IP\naddress sends DHCP REQUEST packet in unicast fashion. And ﬁnally,\nthe server responds with ACK packet. After such conﬁguration the client\ncan communicate with the rest of the network elements in the network.\nThere is also DHCPv6, but it is used for conﬁguration of the IPv6-enabled\nclients. The operation is quite similar to IPv4 version.\n2.4.4 LDAP and other Windows services\nThere are several key Windows protocols that you will typically see in the\nnetwork. LDAP, Kerboros and WINS are just few examples.\nThe Lightweight Directory Access Protocol (LDAP) is an open, vendor-\nneutral application protocol for accessing and maintaining distributed di-\nrectory information services (like user accounts, passwords, and network\nresources) over an IP network. LDAP often operates on TCP port 389.\nThe WINS (Windows Internet Name Service) protocol is a legacy Mi-\ncrosoft service that dynamically maps NetBIOS names (like COMPUT-\n15"
  },
  {
    "source": "analysis",
    "page": 16,
    "text": "Background\nERNAME) to IP addresses (similar to DNS protocol), acting as a central-\nized, dynamic phonebook for older Windows networks, reducing reliance\non noisy network broadcasts for name resolution.\n2.4.5 What about timing: NTP\nKeeping time synchronized in the network is important. Many applica-\ntions rely on accurate timing. For example, application logging system\nputs the timestamps in the ﬁles, precise activation of scheduled jobs re-\nlies on system time, and so on.\nNTP was deﬁned in RFC 5905 [1] and is commonly used by network\ndevices to synchronize clocks. NTP operates on UDP port 123, so it is\nimportant that ﬁrewall will allow this port to be open.\n2.4.6 SSH, TLS and other security protocols\nThere is large body of security protocols. Examples are: HIP, TLS, SSL,\nSSH, IKE, IPsec and many, many more.\nSecure socket layer (SSL) [3] and Transport Layer Security (TLS) [5]\nare an application layer solutions to secure TCP connections. SSL was\nstandardized in RFC 6101. TLS was standardized in RFC 5246. And was\ndesigned to prevent eavesdropping, man-in-the-middle attacks, tamper-\ning, and message forgery. In SSL communicating hosts can authenticate\neach other with the help of longer-term identities - public key certiﬁcates.\nSSL is great for building VPN tunnels and protecting upper-layer proto-\ncols such as HTTP.\nSecure Shell protocol (SSH) is the application layer protocol that pro-\nvides an encrypted channel for insecure networks. SSH was originally\ndesigned to provide secure remote command-line, login, and command ex-\necution. But in fact, any network service can be secured with SSH. More-\nover, SSH provides a means for creating VPN tunnels between spatially\nseparated networks: SSH is a great protocol for forwarding local trafﬁc\nthrough remote servers.\nThere are other security protocols (actually, quite a log). For example,\nHost Identity Protocol. Thus, internet was designed initially so that the\nInternet Protocol (IP) address has a dual role: it is the locator, so that the\nrouters can ﬁnd the recipient of a message, and it is an identiﬁer so that\nthe upper layer protocols (such as TCP and UDP) can make bindings (for\nexample, transport layer sockets use IP addresses and ports to make con-\n16"
  },
  {
    "source": "analysis",
    "page": 17,
    "text": "Background\nnections). This becomes a problem when a networked device roams from\none network to another, and so the IP address changes, leading to failures\nin upper-layer connections. The other problem is the establishment of an\nauthenticated channel between the communicating parties. In practice,\nwhen making connections, the long-term identities of the parties are not\nveriﬁed. Of course, solutions such as SSL can readily solve the problem\nat hand. However, SSL is suitable only for TCP connections, and most\nof the time, practical use cases include only secure web surﬁng and the\nestablishment of VPN tunnels. Host Identity Protocol, on the other hand,\nis more ﬂexible: it allows peers to create authenticated secure channels\non the network layer, so all upper-layer protocols can beneﬁt from such\nchannels. More on the protocol can be found in [6].\nHIP relies on the 4-way handshake to establish an authenticated ses-\nsion. During the handshake, the peers authenticate each other using\nlong-term public keys and derive session keys using Difﬁe-Hellman or\nElliptic Curve (EC) Difﬁe-Hellman algorithms. To combat the denial-of-\nservice attacks, HIP also introduces computational puzzles.\nHIP uses a truncated hash of the public key as an identiﬁer in the form\nof an IPv6 address and exposes this identiﬁer to the upper layer protocols\nso that applications can make regular connections (for example, appli-\ncations can open regular TCP or UDP socket connections). At the same\ntime, HIP uses regular IP addresses (both IPv4 and IPv6 are supported)\nfor routing purposes. Thus, when the attachment of a host changes (and\nso does the IP address used for routing purposes), the identiﬁer, which is\nexposed to the applications, stays the same. HIP uses a particular sig-\nnaling routine to notify the corresponding peer about the locator change.\nMore information about HIP can be found in RFC 7401 [4].\n2.4.7 Watch out for anti-virus\nUpon examination of the logs we have observed that quite a lot of connec-\ntions were made to the anti-virus server. This protocol consumes a lot of\nbandwidth and seems to be vital in modern enterprise networks. In Ta-\nble 3.4 we can see that anti-virus applications sends more packets than\nany other network applications in the system. The bottom line is the fol-\nlowing: not only anti-virus is important in the network and needs to be\ninstalled on all the computers, but also the signature database need to be\nup-to-date.\n17"
  },
  {
    "source": "analysis",
    "page": 18,
    "text": "Background\n18"
  },
  {
    "source": "analysis",
    "page": 19,
    "text": "3. Results\nAnalyzing the trafﬁc in the company on regular basis can be benﬁcial for\nseveral reasons: (i) we can ﬁnd strange behaviour of computers in the\nnetwork, (ii) we can ﬁnd the bottlenecks, (iii) we can detect misconﬁgura-\ntions in networked devices. In the paragraphs that follow we present the\nanalysis trafﬁc which was captured in a small enterprise network.\n3.1 Data collection\nWe begin this section with a description of the enterprise network, with\nthe details of data capturing process to follow. According to Cisco docu-\nmentation [7], our network was two-tier medium-sized enterprise network\ncomprising slightly more than 200workstations, one distribution switch\n(Cisco Catalyst G3560 series layer 3 switch), one router (the router was\nrunning Linux operating system) playing the role of a VLAN router ,6ac-\ncess switches from various vendors (1 DLink DES3200, 1 Cisco 2690, 2\nDLink DES1226 and 2 XNET SH9024 switches) and also multiple, non-\nmanaged switches and one wireless access point all being connected to\naccess switches.\nSince we were unable to analyze fully the wiring of the access (especially\nthose that were spread around the building and connected directly to ac-\ncess switches) and distribution switches, we could basically only guess\n(based on the limited information we had at our disposal) that there were\nno redundant links between access and distribution switches, also there\nwere no redundant links between distribution switch and VLAN router.\nEssentially, the switches were merely connected in a tree like topology:\neach access switch was connected to one distribution switch, and the dis-\ntribution switch was connected to a single router over a gigabit Ethernet\ntrunk link.\n19"
  },
  {
    "source": "analysis",
    "page": 20,
    "text": "Results\nFigure 3.1. Enterprise network architecture\nThe entire network was partitioned into 25broadcast domains (VLANs),\nwith native VLAN (VLAN that does not have tagging) being reserved for\ninfrastructure management, although not all the switches were using na-\ntive VLAN for management purposes. For brevity and privacy reasons we\nomit the discussion of network addressing in full detail, but rather men-\ntion that all VLANs were assigned addresses from class C private network\nfrom 192.168.0.0 to 192.168.24.0, whereas the last usable address in each\nsubnetwork was used as the address for the default gateway. All hosts in\nthe network used static address assignment schema.\nTo capture the trafﬁc it was natural to place packet capturing at the\ncentral router, rather than installing it on multiple switches. With this\nrespect, we conﬁgured sniffer at the router to capture the frames on a\ngigabit trunk interface. We have used tcpdump to capture all trafﬁc on the\ntrunk link of a router - the link which was connected to the distribution\nswitch. The data collection period lasted for slightly more than 2:5hours,\nfrom 06 : 23 UTC to 09 : 03 UTC and 19:1\u0001106frames were collected in\ntotal. Of course, this is not enough for the full picture (in practice the\ntrafﬁc needs to be collected for at least one week, but this interval was\nsufﬁcient to understand what kind of trafﬁc existed in the network). Once\nthe data was collected, a single pcap ﬁle was created. We then started to\npreprocess the captured data.\n20"
  },
  {
    "source": "analysis",
    "page": 21,
    "text": "Results\nTable 3.1. Distribution of non IPv4 frames\nProtocol Number of frames Fraction (%)\nARP 136857 48.8\nCisco Shared Spanning Tree Protocol 119385 42.5\nIPv6 17034 6.1\nSpanning Tree Protocol (IEEE 802.1D) 4774 1.7\nIPX 1164 0.4\nCisco Loop 957 0.3\nCisco CDP/VTP 510 0.2\n3.2 Breakdown of the network protocols in small enterprise\nnetwork\nTo perform the preprocessing we have extracted the binary data and stored\nit in pdml (Packet Description Markup Language) format - a special XML\nformat which is used to describe the contents of the binary representation\nof frames and packets.\nOur next step was to extract needed ﬁelds from the XML ﬁle and store\nthe extracted data in the format which was simpler for further analysis.\nThus, we have chosen JSON (JavaScript Object Notation) format. From\nPDML we have extracted the following ﬁelds:\n• Ethernet source and destination MAC addresses and type ﬁeld\n• VLAN identiﬁer and type ﬁeld\n• From IP header we have extracted source and destination addresses,\nversion number, length, protocol type, and TTL.\n• Basic information from GRE and PPP headers (since clients accessing\nthe Internet were using these protocols)\n• From TCP header we have selected source and destination ports, stream\nidentiﬁer, length, sequence and acknowledgment numbers, as well as\nﬂags and window size.\n• From UDP header source and destination ports, as well as datagram\nlength information were extracted.\nOur next step in preprocessing the data was to extract non IPv4 frames\n21"
  },
  {
    "source": "analysis",
    "page": 22,
    "text": "Results\n- frames for which neither Ethernet type nor VLAN type ﬁeld were equal\nto0x00008000 (this dataset includes packets from all VLANs as well as\npackets from native VLAN). Once the data was extracted we binned the\nframes according to protocol types. In Table 3.1 we present the summary\nresults for this data.\nTable 3.2. Distribution of protocols in native VLAN\nProtocol Number of frames Fraction (%)\nCisco Shared Spanning Tree Protocol 4774 40.5\nSpanning Tree Protocol (IEEE 802.1D) 4774 40.5\nCisco Loop protocol 957 8.1\nIP (ICMP only) 640 5.4\nCisco CDP/VTP 510 4.3\nARP 128 1.1\nTable 3.3. Frames with invalid MAC addresses\nSource MAC Destination MAC Source IP Destination IP Manufacturer\n30:f9:ed:41:a6:01 00:c0:ee:9a:5a:85 192.168.5.10 192.168.5.151 Sony/KYOCERA\n00:30:05:c2:b7:ff 00:17:c8:03:a0:7b 192.168.18.7 192.168.18.34 Fujitsu/KYOCERA\n00:15:58:67:5f:14 00:c0:ee:9a:5a:85 192.168.5.3 192.168.5.151 FOXCONN/KYOCERA\nThe next step in preprocessing of the data was to exclude the frames for\nthe native VLAN from the traces. Thus, we have ﬁltered out the frames\nfor which Ethernet type was not equal to 0x00008100 . It turned out that\nthe fraction of frames without VLAN tag was rather small and constituted\nonly 0:06% of the total number of frames in the trace. Since native VLAN\nwas used only for management purposes we excluded it from further anal-\nysis. However, in Table 3.2 we show the distribution of packet types seen\nin the native VLAN.\nTable 3.4. Distribution of top applications used in the network\nTCP port Frequency Application UDP port Frequency Application\n13000 11599 Kaspersky 53 27960 DNS\n443 10128 HTTPS 137 6589 NetBIOS\n88 9700 Kerboros 389 1350 LDAP\n80 6938 HTTP 15000 804 Kaspersky Network Agent\n445 5581 Microsoft SMB 88 166 Kerboros\n135 940 MS RPC 123 146 NTP\n389 880 LDAP 13000 50 Kaspersky\n49155 694 Microsoft-DC 138 21 NetBIOS\n139 682 Netbios 443 16 QUIC\nInstead, next we turned our attention to frames with invalid MAC ad-\ndresses. By invalid MAC address we mean those MAC addresses which\nare not multicast or broadcast addresses received at the trunk interface\n22"
  },
  {
    "source": "analysis",
    "page": 23,
    "text": "Results\nof the router with destination unicast MAC addresses not of router’s own\nMAC addresses. Upon ﬁltering the data we have found that there were\ntwo such destination unicast MAC addresses. We hypothesize that such\nframes could have been received at the trunking interface due to the fol-\nlowing reasons. The MAC address table of the switches (i) did not contain\na record for the destination MAC address and so it was ﬂooded to all ports\nexcept the port from which the frame was received; (ii) wrong mapping for\nthe destination MAC address and outgoing interfaces could have existed\nand so it was forwarded into the wrong port of the switch and thus was re-\nceived at the trunk port of the router. The two invalid MAC addresses we\nhave discovered are: 00:17:c8:03:a0:7b and00:c0:ee:9a:5a:85 . We leave\nthis investigation to the network administrators.\nOur next step of data preprocessing was to ﬁnd for every packet being\nforwarded a corresponding pair: Note, our trace contained two copies of\na packet for which the source and destination IP addresses where within\nthe192.168.0.0/16 subnetwork with a difference that TTL was reduced\nby one for one of the packets, and the Ethernet header was recalculated.\nThus, by ﬁltering out the duplicates we were able to excluded the possibil-\nity of overcounting the number of bytes carried in TCP and UDP streams,\nand other transport protocols. To perform this ﬁltering step, we merely\nfound all packets whose source and destination addresses where within\nthe subnetwork 192.168.0.0/16 and ﬁltered out frames for which source\nMAC address was not equal to the MAC address of the VLAN server (note,\nall VLAN interfaces were assigned the same MAC address). Thus, effec-\ntively leaving only one copy of the packet being forwarded between the\nsubnetworks in the trace. Our resulting trace was reduced by 35:4%, and\nnow contained 12190001 frames.\nOnce again we have searched for frames with invalid MAC addresses\n(we have introduced the term invalid MAC addresses in the previous\nparagraphs). In Table 3.3 we list these MAC addresses as well as cor-\nresponding IP addresses found in such frames, and manufacture’s name.\nObviously, such disripancy is strange.\nFor the cleaned data, our ﬁrst step was to take a look at the distribu-\ntion of TCP and UDP applications and the number of bytes these applica-\ntions transmitted. Thus, in Table 3.4 we show the distribution of 9most\nused UDP and TCP applications. We examened both inter-VLAN and\nInternet trafﬁc. We observed that while most of hosts were not actively\nconnected to the Internet, using the VPN connections, 15366 connection\n23"
  },
  {
    "source": "analysis",
    "page": 24,
    "text": "Results\n●●\n●●\n●●\n●●\n●●●\n●●\n●●\n●●\n●●●\n●●\n●●●\n●●●\n●\n●●●●\n●\n●●\n●●●●●\n●●●\n●\n●●●●●\n●●\n●●\n●\n●\n●●\n●●\n●●\n●●●\n●●\n●●\n●●\n●●●\n●●●\n●●\n●●●\n●●\n●●\n●●\n●●\n●\n●●●\n●\n●\n●●●●\n●●●●\n●●\n●●\n●\n●●●●\n●\n●●\n●●\n●\n●●\n●\n●●●\n●●\n●●\n●●●\n●●\n●●\n●●\n●● ●\n●●\n●\n●●\n●\n●●\n●●●\n●●\n169.254.171.39192.168.0.1\n192.168.0.2192.168.0.254\n192.168.0.5192.168.10.1\n192.168.10.2192.168.10.254\n192.168.10.4192.168.10.6192.168.11.1\n192.168.11.5\n192.168.111.114\n192.168.111.119192.168.111.67\n192.168.111.87192.168.12.1\n192.168.12.254192.168.13.1192.168.13.254\n192.168.13.3192.168.13.6\n192.168.13.7192.168.13.8192.168.13.9\n192.168.14.1192.168.14.254192.168.14.3\n192.168.14.5\n192.168.15.10192.168.15.12192.168.15.14\n192.168.15.16\n192.168.15.17\n192.168.15.2192.168.15.254\n192.168.15.4192.168.15.6192.168.15.8192.168.16.102192.168.16.103\n192.168.16.104192.168.16.105192.168.16.106\n192.168.16.107\n192.168.16.108192.168.16.109192.168.16.110192.168.16.111192.168.16.113\n192.168.16.114192.168.16.115\n192.168.16.118192.168.16.119\n192.168.16.12\n192.168.16.120\n192.168.16.14192.168.16.15\n192.168.16.16\n192.168.16.254\n192.168.16.4192.168.16.6\n192.168.16.7192.168.16.8192.168.18.1\n192.168.18.10192.168.18.12\n192.168.18.2192.168.18.211\n192.168.18.22192.168.18.254\n192.168.18.3192.168.18.4192.168.18.5\n192.168.18.7192.168.18.8\n192.168.18.9\n192.168.19.1192.168.19.2\n192.168.19.254192.168.19.3192.168.19.4\n192.168.2.1192.168.2.10\n192.168.2.2 192.168.2.254\n192.168.2.3192.168.2.4\n192.168.2.5192.168.20.1\n192.168.20.2\n192.168.21.1192.168.222.10192.168.222.103\n192.168.222.106\n192.168.222.24\n192.168.222.39192.168.222.51\n192.168.222.60192.168.222.88\n192.168.222.94192.168.222.95192.168.222.97192.168.23.105\n192.168.23.13192.168.23.254\n192.168.3.6192.168.4.1\n192.168.4.2\n192.168.4.254192.168.4.3\n192.168.4.4192.168.5.10\n192.168.5.3\n192.168.6.1192.168.6.10\n192.168.6.2192.168.6.254\n192.168.6.3\n192.168.6.4192.168.6.6\n192.168.6.7\n192.168.6.8192.168.6.9192.168.7.1\n192.168.7.101192.168.7.103\n192.168.7.104192.168.7.105\n192.168.7.108192.168.7.111192.168.7.112\n192.168.7.113192.168.7.114\n192.168.7.115192.168.7.117\n192.168.7.2192.168.7.254\n192.168.7.4192.168.7.52 192.168.7.56\n192.168.7.57192.168.7.58\n192.168.7.6\n192.168.7.60192.168.7.61\n192.168.7.7\n192.168.7.96192.168.8.1\n192.168.8.2192.168.8.254192.168.8.3\n192.168.9.4192.168.9.5\nFigure 3.2. Interaction between computers in different VLANs over TCP\nattemps were made towards the Internet (only TCP SYN packet was cap-\ntured, which was dropped by the ﬁrewall). This could be an indication\nthat quite a lot of connections are made in fact in a stealth mode on users’\ncomputers.\nNext we computed the distribution of the packet sizes for packets with\nvalid IP addresses. Interestingly there were frames which were larger\nthan maximum allowed Ethernet frames size (so called jumbo frames).\nAround 10% of the IPv4 packet were larger than 1500 bytes. In Figure 3.3\nwe show this distribution.\nTo ﬁnilize the discussion, we have also plotted the distribution of port\nand IP addresses. In Figure 3.4 we show this distribution.\n3.3 Watch out! We are plotting the network map\nNext, we have computed the adjacency graph for computers which were\ninteracting over TCP in the local network (an interaction here means that\nat least one TCP/UDP connection between the pair of computers existed).\nAs it was expected, only few computers (servers) were accepting all TCP\n24"
  },
  {
    "source": "analysis",
    "page": 25,
    "text": "Results\nDistribution of frame sizes\nFrame size (bytes)Frequency\n0 500 1000 1500 2000 2500 30000.0000 0.0020\n500 1000 1500 2000 25000.00.40.8\nFrame sizesProbability\nFigure 3.3. Distribution of frame sizes\nconnections, with a small fraction of computers were interacting between\neach other. Upon expecting closely the logs we have found few interesting\nthings: (i) at least one machine had misconﬁgured address (it was using\nself generated IP addresses with the preﬁx 169:254:171:0=24); (ii) only two\nmachines were interacting with non-server computers 192:168:23:13and\n192:168:3:6using ports 139and 445.\n3.4 Performance, performance and once again performance:\nStressing the network\nWe have also stress-tested the network on ragular bases. For example, we\nhave tested the bandwidth between the gateway and the host in the In-\nternet in order to udnerstand the performance of the outside network. In\naddition it is important to measure the performance of the links between\nhosts and servers. All this is done with the monitoring software.\n25"
  },
  {
    "source": "analysis",
    "page": 26,
    "text": "Results\nPort number\n# of hosts\n192.168.0.0\n192.168.10.0\n192.168.11.0\n192.168.13.0\n192.168.14.0\n192.168.15.0\n192.168.16.0\n192.168.18.0\n192.168.19.0\n192.168.2.0\n192.168.20.0\n192.168.23.0\n192.168.4.0\n192.168.5.0\n192.168.6.0\n192.168.7.0\n192.168.8.0\n192.168.9.0212223255380881101351391432222803894434454644654755155545875936316367449909939951000102110251026102711101433154015411723210531283268326933894899500055556002610161067001700280008080910010000\nFigure 3.4. Distribution of ports used in the network\n3.5 VPN connections\nFinally, we have monitored the long-living VPN connections. Upon doing\nso, we have noticed that service providers do not play nicely with such\nconnections. For example, we have observed that TCP connections can\nenter so called stale state: ACKs do not go through in both directions, but\nonly one. In this case, the connection remains in ESTABLISHED state,\nbut the data does not go through. The result of the sequence progress is\nshown in Figure 3.5.\nClearly, drop of the spikes indicate TCP connection restarts. But one\nthing is really interesting, the last TCP connection restarts successfully,\nbut the sequences are progressing only for one direction: from client to\nserver. The data does not go through the CGN from server to client and\nthe TCP connection hangs.\n26"
  },
  {
    "source": "analysis",
    "page": 27,
    "text": "Results\n0e+00 1e+05 2e+05 3e+05 4e+05 5e+05 6e+050.0e+00 1.0e+08Server−Client\nPacketSequence\n0e+00 1e+05 2e+05 3e+05 4e+05 5e+05 6e+050e+00 3e+07 6e+07Client−Server\nPacketSequence\nFigure 3.5. TCP sequence progress in both directions\n27"
  },
  {
    "source": "analysis",
    "page": 28,
    "text": "Results\n28"
  },
  {
    "source": "analysis",
    "page": 29,
    "text": "4.Conclusions\nIn this short report we have played a bit with the packets which were\ncaptured in a small enterprise. Our primary goal was to analyse the in-\nteractions of computers and build the statistics for the trafﬁc which was\ncaptured for several hours. Our key ﬁndings are the following: (i) major\ntrafﬁc in the network is HTTPS and HTTP, (ii) antivirus solutions con-\nsume considerable amount of bandwidth, (iii) computers in the network\nmainly interact with the default gateway and few servers, such as NFS\nserver and mail server.\n29"
  },
  {
    "source": "analysis",
    "page": 30,
    "text": "Conclusions\n30"
  },
  {
    "source": "analysis",
    "page": 31,
    "text": "Bibliography\n[1] Network Time Protocol Version 4: Protocol and Algorithms Speciﬁcation.\nhttps://datatracker.ietf.org/doc/html/rfc5905.\n[2] A one-way delay metric for ip performance metrics (ippm).\nhttps://datatracker.ietf.org/doc/rfc7679/.\n[3] RFC 6101: The Secure Sockets Layer (SSL) Protocol Version 3.0.\nhttps://datatracker.ietf.org/doc/html/rfc6101.\n[4] RFC 7401: Host Identity Protocol Version 2 (HIPv2). https://www.rfc-\neditor.org/rfc/rfc7401.html.\n[5] RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2.\nhttps://datatracker.ietf.org/doc/html/rfc5246, 2008.\n[6] G URTOV , A. Host Identity Protocol (HIP): Towards the Secure Mobile Inter-\nnet. 2008.\n[7] O DOM , W. CCENT/CCNA ICND1 100-105 Ofﬁcial Cert Guide . 2016.\n31"
  }
]
